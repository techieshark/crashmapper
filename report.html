<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Haskell Crash Mapper</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="generator" content="pandoc" /><meta name="author" content="Peter W for CS 457 Functional Languages" /><meta name="date" content="June 2009" /><style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
pre.sourceCode { }
pre.sourceCode span.Normal { }
pre.sourceCode span.Keyword { color: #007020; font-weight: bold; } 
pre.sourceCode span.DataType { color: #902000; }
pre.sourceCode span.DecVal { color: #40a070; }
pre.sourceCode span.BaseN { color: #40a070; }
pre.sourceCode span.Float { color: #40a070; }
pre.sourceCode span.Char { color: #4070a0; }
pre.sourceCode span.String { color: #4070a0; }
pre.sourceCode span.Comment { color: #60a0b0; font-style: italic; }
pre.sourceCode span.Others { color: #007020; }
pre.sourceCode span.Alert { color: red; font-weight: bold; }
pre.sourceCode span.Function { color: #06287e; }
pre.sourceCode span.RegionMarker { }
pre.sourceCode span.Error { color: red; font-weight: bold; }
</style><link rel="stylesheet" href="pandoc.css" type="text/css" media="all" />
</head><body><h1 class="title">Haskell Crash Mapper</h1><center><p>Creating Google Earth maps of bicycle crashes in Washington County</p>Peter W | June 2009 | CS 457 @ PSU</center>
<hr /><h1 id="introduction">Introduction</h1><h2 id="background">Background</h2><p>Oregon is nationally known for its efforts to promote bicycling &amp; walking. In 1971 the state passed a bill requiring that all new or reconstructed roads have bike lanes, and that the State and local governments spend at least 1% of transportation funds on bicycle and pedestrian projects. In 2005 Oregon put an emphasis on biking and walking at a young age with the announcement of $5 million for the Safe Routes To School program which gives grants to schools and local governments to create encouragement and educational programs or to improve the safety of transportation infrastructure near schools. And in late 2008, the Oregon Tourism Commission announced it was beginning work on a new website devoted to bicycle touring in the state.</p><p>However, despite (or because of?) pouring billions&mdash;if not trillions&mdash;of dollars on our nation&rsquo;s transportation infrastructure, vehicle crashes are still a leading cause of death in the US. Every year, over 40,000 Americans are killed in automobile crashes.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> The Federal Highway Administration (FWA) reports that</p><blockquote><p>&ldquo;bicyclists and pedestrians remain over-represented in crash statistics, accounting for almost 15 percent of all fatalities but only 7 percent of trips and an even smaller percentage of total miles traveled.&rdquo;<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p></blockquote><p>Citing figures from the FWA, the League of American Bicyclists estimates that the sum of the economic costs of every person injured or killed since 2000 is $3.1 and $2.1 billion, respectively.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p><p>Unfortunately, despite the high costs of a dangerous transportation system, in terms of both dollars and lives, politicians and transportation agencies often prioritize projects which increase capacity over those that improve safety. This is even the case in Oregon, as evidenced by the recent passage of HB 2001, the &ldquo;Jobs and Transportation Act&rdquo;. The bill specifically earmarks over $840 million of the total $1 billion to be spent on highway projects, and legislates that two-thirds of the money will go towards building new highway capacity and interchanges.</p><p>Why is roadway capacity so often prioritized over safety? We believe it is in large part due to the fact that the average person can much more easily visualize and quantify traffic congestion then they can for safety problems. It is easy to see a traffic jam. It is difficult to see how frequent and widespread crashes are. You can measure how long you sit in traffic, but if can&rsquo;t even visualize the broad extent of safety issues, how can you possibly quantify them or their effects?</p><p>But what if these everyday people could visualize and quantify traffic crashes and their aftermath? If the devastation and destruction could be made tangible, would politicians be more likely to appreciate the severity of the problem and the need for action? This brings us to our primary objective.</p><h2 id="objective">Objective</h2><p>The objective of this project is to make a first pass towards that ideal solution to the problem of visualizing and quantifying crashes, and aims to address these specific questions:</p><ul><li>Can we create a tool to map bicycle and pedestrian crashes in Oregon?</li><li>Can this tool make crash information accessible to average citizens in a way that enables custom visualizations and investigations?</li></ul><p>To proceed towards such a tool, we will use the powerful programming language Haskell, the widely used and user friendly geographic visualization tool, Google Earth, and a dataset of crash records from the Oregon Department of Transportation (ODOT). Our goal will be to read in the set of crashes and output a file which can be viewed in Google Earth. Using Google Earth, users will be able to see the location of every crash, and when they select a crash, detailed information about it will be displayed. Each of these crashes will be tagged with a timestamp as well, so the user may perform time based actions, such as taking a tour (in chronological order) of all crashes, or asking Google Earth to only show crashes during a specified time period.</p><p>In the next section, we will discuss the data and formats involved.</p><h2 id="data">Data</h2><h3 id="kml">KML</h3><p>KML is an XML data format for storing geographic information. Originally a proprietary format when Google Earth was the &lsquo;Keyhole&rsquo; product (before Google acquired it), it is now an open standard. According to the Google online KML reference, &ldquo;KML is an open standard officially named the OpenGISÂ® KML Encoding Standard (OGC KML). It is maintained by the Open Geospatial Consortium, Inc. (OGC)&rdquo;.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p><p>Google&rsquo;s online <a href="http://code.google.com/apis/kml/documentation/kmlreference.html">KML Reference</a> is the best place to discover all the details of the format, but we&rsquo;ll just go over the basics here:</p><p>A KML file begins with: <code>&lt;kml xmlns=\&quot;http://www.opengis.net/kml/2.2\&quot;&gt;</code> and ends with <code>&lt;/kml&gt;</code>.</p><p>The file can contain Placemarks (geographic locations), Folders, and other elements. A Placemark has a name, address, description, and may have a timestamp.</p><p>Here is an example of a simple KML file which contains one placemark for PSU, is stored in the &ldquo;Oregon Universities&rdquo; folder, and has a timestamp for the time the school first opened:</p><pre class="sourceCode xml"><code><span class="Keyword Element">&lt;kml</span><span class="Others Attribute"> xmlns=</span><span class="String Value">&quot;http://www.opengis.net/kml/2.2&quot;</span><span class="Keyword Element">&gt;</span><br /><span class="Keyword Element">&lt;Folder&gt;</span><br /><span class="Keyword Element">&lt;name&gt;</span><span class="Normal NormalText">Oregon Universities</span><span class="Keyword Element">&lt;/name&gt;</span><br /><span class="Normal NormalText">    </span><span class="Keyword Element">&lt;Placemark&gt;</span><br /><span class="Normal NormalText">        </span><span class="Keyword Element">&lt;name&gt;</span><span class="Normal NormalText">Portland State University</span><span class="Keyword Element">&lt;/name&gt;</span><br /><span class="Normal NormalText">        </span><span class="Keyword Element">&lt;address&gt;</span><span class="Normal NormalText">1825 SW Broadway, Portland, OR 97201</span><span class="Keyword Element">&lt;/address&gt;</span><br /><span class="Normal NormalText">        </span><span class="Keyword Element">&lt;description&gt;</span><span class="Normal NormalText">PSU is Oregon's largest university. </span><br /><span class="Normal NormalText">            It was founded in 1946, and lets say it opened at 9am on September 23rd.</span><br /><span class="Normal NormalText">        </span><span class="Keyword Element">&lt;/description&gt;</span><br /><span class="Normal NormalText">        </span><span class="Keyword Element">&lt;TimeStamp&gt;&lt;when&gt;</span><span class="Normal NormalText">1946-09-23T09:00:00-08:00</span><span class="Keyword Element">&lt;/when&gt;&lt;/TimeStamp&gt;</span><br /><span class="Normal NormalText">    </span><span class="Keyword Element">&lt;/Placemark&gt;</span><br /><span class="Keyword Element">&lt;/Folder&gt;</span><br /><span class="Keyword Element">&lt;/kml&gt;</span><br /></code></pre><h2 id="odot-crash-data">ODOT Crash Data</h2><p>The Oregon Department of Transportation (ODOT) Crash Analysis and Reporting Unit maintains a set of records of all reported traffic crashes going back at least 10 years. Upon request, they provided two Comma Separated Value (CSV) exports: one of all the crashes involving bicycles, and the other for crashes involving pedestrians. To reduce the amount of data involved for the first version of the application, ODOT exported only crashes occuring within Washington County (the only significance of this particular location is that it is where this author lives).</p><p>The CSV format is a simple text format where records are separated by newline characters and fields within records are just character strings separated by commas.</p><p>The full crash record set is quite complicated. Each record has 98 fields, which cover everything about the crash: what, when, where, who, why, and how. For example, it includes information about the types of vehicles involved, the number of people involved, how the crash happened (head-on vs angle movement), roadway information such as surface condition, speed limit, number of lanes, etc. Eventually, this application can be extended to deal with most of that data, but for the purposes of development, the records were slimmed down to just these basic 14 fields, shown below along with a short description:</p><table><tr class="header"><th align="right" style="width: 33%;">Field</th><th align="left" style="width: 55%;">Descripton</th></tr><tr class="odd"><td align="right">Crash ID</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">Unique identifier for this crash</td></tr><tr class="odd"><td align="right">Crash Month</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">01 = Jan, 12 = Dec, etc.</td></tr><tr class="odd"><td align="right">Crash Day</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">01&ndash;31</td></tr><tr class="odd"><td align="right">Crash Year</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">YYYY format.</td></tr><tr class="odd"><td align="right">Week Day Code</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">1=Sun 7=Sat [redundant, but convenient]</td></tr><tr class="odd"><td align="right">Crash Hour</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">00 = 12am&ndash;12:59pm. 23 = 11pm&ndash;11:59pm.</td></tr><tr class="odd"><td align="right"></td><td align="left">24: not used.&nbsp;99: unknown time.</td></tr><tr class="even"><td align="right">City</td><td align="left"></td></tr><tr class="odd"><td align="right"></td><td align="left">Unique city identifier,</td></tr><tr class="even"><td align="right"></td><td align="left">or blank if outside city limits</td></tr><tr class="odd"><td align="right">Street #</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">Street on which crash occured.</td></tr><tr class="odd"><td align="right"></td><td align="left">When combined with city ID,</td></tr><tr class="even"><td align="right"></td><td align="left">we can lookup a street name</td></tr><tr class="odd"><td align="right">Nearest Intersecting Street</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">same format at Street #</td></tr><tr class="odd"><td align="right">Distance From Intersection</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">blank: unknown</td></tr><tr class="odd"><td align="right"></td><td align="left">0000: in intersection</td></tr><tr class="even"><td align="right"></td><td align="left">0001&ndash;9998: dist.&nbsp;in feet</td></tr><tr class="odd"><td align="right"></td><td align="left">9999: over 9999 feet</td></tr><tr class="even"><td align="right">Direction From Intersection</td><td align="left"></td></tr><tr class="odd"><td align="right"></td><td align="left">0: Unknown</td></tr><tr class="even"><td align="right"></td><td align="left">1: North</td></tr><tr class="odd"><td align="right"></td><td align="left">2: Northeast</td></tr><tr class="even"><td align="right"></td><td align="left">3: East</td></tr><tr class="odd"><td align="right"></td><td align="left">4: Southeast</td></tr><tr class="even"><td align="right"></td><td align="left">5: South</td></tr><tr class="odd"><td align="right"></td><td align="left">6: Southwest</td></tr><tr class="even"><td align="right"></td><td align="left">7: West</td></tr><tr class="odd"><td align="right"></td><td align="left">8: Northwest</td></tr><tr class="even"><td align="right"></td><td align="left">9: Center of the Intersection</td></tr><tr class="odd"><td align="right">Crash Type</td><td align="left"></td></tr><tr class="even"><td align="right"></td><td align="left">3: pedestrian</td></tr><tr class="odd"><td align="right"></td><td align="left">6:bike</td></tr><tr class="even"><td align="right">Collision Type</td><td align="left"></td></tr><tr class="odd"><td align="right"></td><td align="left">1: Angle</td></tr><tr class="even"><td align="right"></td><td align="left">2: Head-On</td></tr><tr class="odd"><td align="right"></td><td align="left">3: Rear-End</td></tr><tr class="even"><td align="right"></td><td align="left">4: Sideswipe-meeting</td></tr><tr class="odd"><td align="right"></td><td align="left">5: Sideswipe-overtaking</td></tr><tr class="even"><td align="right"></td><td align="left">6: Turning Movement</td></tr><tr class="odd"><td align="right"></td><td align="left">7: Parking Movement</td></tr><tr class="even"><td align="right"></td><td align="left">8: Non-collision</td></tr><tr class="odd"><td align="right"></td><td align="left">0: Fixed- or Other- object</td></tr><tr class="even"><td align="right"></td><td align="left">-: Backing</td></tr><tr class="odd"><td align="right"></td><td align="left">&amp;: Miscellaneous</td></tr><tr class="even"><td align="right">Crash Severity</td><td align="left"></td></tr><tr class="odd"><td align="right"></td><td align="left">2: fatal</td></tr><tr class="even"><td align="right"></td><td align="left">4: nonfatal</td></tr></table><p>A secondary file, streets.csv, was supplied by ODOT which we use as a lookup table for the street and city IDs. The file is a CSV file where each record has the following four fields: CountyID (e.g., &ldquo;34&rdquo; for Washington County), StreetID, StreetName, CityID, CityName.</p><p>A number of simplifying assumptions were made:</p><ul><li>In the crash CSV file, multiple records have the same Crash ID. This is because each crash is split into a record for just the crash data and records for participant and vehicle data. Since the record with the crash data has all the info we are currently interested in, the other records were deleted from the CSV file. After doing that, each Crash ID in the file is unique.</li><li>ODOT only gave us data for Washington County, so we ignore the County field in the crash records, and we can assume that all streets are in Washington County and ignore the County field in the streets.csv file.</li><li>There are two ways that locations are encoded in the crash data set. One is by distance in feet from intersections. The other is by distance (milepoints) along a mile-marked road (like highways). In Washington County, crashes on county roads are recorded in the same way as crashes on city streets: as distance from intersections. Crashes on highways in cities are similarly encoded. Crashes on highways outside cities are coded using the milepoint system. For the first implimentation of this application, we removed crashes encoded using the milepoint system because that would involve more complex GIS work that is outside the scope of this project.</li><li>Crashes where severity was &ldquo;Property Damage Only&rdquo; were removed (there were only a few).</li></ul><p>The following reference files contain extensive documentation about the ODOT files:</p><ul><li>RawDataExtract_Layout.doc: brief summary of all files in the CSV output.</li><li>2007DecodeManual2.0.pdf: 202 page detailed manual covering all fields and their meanings</li></ul><h1 id="implementation">Implementation</h1><h2 id="the-basics-csv---kml">The Basics: CSV -&gt; KML</h2><p>Diving straight into creating code to parse the ODOT crash data seemed daunting, so the tasks of reading in CSV files and writing to KML files were tackled first.</p><p>To read the CSV file, a small amount of code was copied from the Real World Haskell book. <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></p><p>Here&rsquo;s part of that code:</p><pre class="sourceCode haskell"><code><span class="Keyword">import</span><span class="Normal NormalText"> </span><span class="Normal ModuleName">Text.ParserCombinators.Parsec</span><br /><br /><span class="Normal NormalText">csvFile = endBy line eol</span><br /><span class="Normal NormalText">line = sepBy cell (char </span><span class="Char">','</span><span class="Normal NormalText">)</span><br /><span class="Normal NormalText">cell = quotedCell &lt;|&gt; many (noneOf </span><span class="String">&quot;,\n\r&quot;</span><span class="Normal NormalText">)</span><br /></code></pre><p>The function &lsquo;csvFile&rsquo; is most useful to us. It is of type <code>GenParser Char st [[String]]</code>. This will be passed to Parsec&rsquo;s <code>parse</code> function, and will parse a list of characters and return a list of lists of strings. Some type synonmys that we add to the CSV.hs file make it easier to get our head around that return type:</p><pre class="sourceCode haskell"><code><span class="Keyword">type</span><span class="Normal NormalText"> CSV = [Record]</span><br /><span class="Keyword">type</span><span class="Normal NormalText"> Record = [Field]</span><br /><span class="Keyword">type</span><span class="Normal NormalText"> Field = </span><span class="DataType TypeConstructor">String</span><br /></code></pre><p>That is, when the input string is parsed, a CSV is returned. A CSV represents a CSV file, whic is a list of records, where each record (or line) is a list of fields. Each field is simply a string (and fields are separated by commas, which we don&rsquo;t need to worry about any more since the parser takes care of that).</p><p>To use the CSV code in our application, we store it in CSV.hs and export it as part of a module definition which begins at the top of that file:</p><pre class="sourceCode haskell"><code><span class="Keyword">module</span><span class="Normal NormalText"> CSV (csvFile, </span><br /><span class="Normal NormalText">            parse, </span><br /><span class="Normal NormalText">            CSV,</span><br /><span class="Normal NormalText">            Record,</span><br /><span class="Normal NormalText">            Field</span><br /><span class="Normal NormalText">           ) </span><span class="Keyword">where</span><br /></code></pre><p>To try out this code, we create a sample CSV file, sample.csv:</p><pre><code>&quot;1&quot;,&quot;bike&quot;,&quot;7105 NE Rocky Brook St&quot;,&quot;Hillsboro&quot;,&quot;OR&quot;,&quot;97124&quot;
&quot;2&quot;,&quot;ped&quot;,&quot;18880 SW Hart Rd&quot;,&quot;Aloha&quot;,&quot;OR&quot;,&quot;97007&quot;
&quot;3&quot;,&quot;bike&quot;,&quot;1831 SW Park Ave #208&quot;,&quot;Portland&quot;,&quot;OR&quot;,&quot;97201&quot;
</code></pre><p>(Note that the records are much simpler than the full ODOT data.)</p><p>An early version of our code simply calls the parser and prints the records in a human readable format:</p><pre class="sourceCode haskell"><code><span class="Normal NormalText">main =</span><br /><span class="Normal NormalText">    </span><span class="Keyword">do</span><span class="Normal NormalText"> c &lt;- </span><span class="Function">getContents</span><br /><span class="Normal NormalText">       </span><span class="Keyword">case</span><span class="Normal NormalText"> parse csvFile </span><span class="String">&quot;(stdin)&quot;</span><span class="Normal NormalText"> c </span><span class="Keyword">of</span><br /><span class="Normal NormalText">            </span><span class="Keyword DataConstructor">Left</span><span class="Normal NormalText"> e -&gt; </span><span class="Keyword">do</span><span class="Normal NormalText"> </span><span class="Function">putStrLn</span><span class="Normal NormalText"> </span><span class="String">&quot;Error parsing input:&quot;</span><br /><span class="Normal NormalText">                         </span><span class="Function">print</span><span class="Normal NormalText"> e</span><br /><span class="Normal NormalText">            </span><span class="Keyword DataConstructor">Right</span><span class="Normal NormalText"> r -&gt; </span><span class="Keyword">do</span><span class="Normal NormalText"> </span><span class="Function">putStrLn</span><span class="Normal NormalText"> (csvToText r)</span><br /><br /><span class="Comment">-- Helper function to convert CSV to output string.</span><br /><span class="Function FunctionDefinition">csvToText ::</span><span class="Normal NormalText"> [Record] -&gt; </span><span class="DataType TypeConstructor">String</span><br /><span class="Normal NormalText">csvToText c = </span><span class="Function">unlines</span><span class="Normal NormalText"> $ </span><span class="Function">map</span><span class="Normal NormalText"> stringFromRecord c</span><br /><br /><span class="Comment">-- Helper function to convert 1 line of CSV file to a string.</span><br /><span class="Function FunctionDefinition">stringFromRecord ::</span><span class="Normal NormalText"> Record -&gt; </span><span class="DataType TypeConstructor">String</span><br /><span class="Normal NormalText">stringFromRecord r = </span><span class="String">&quot;Id: &quot;</span><span class="Normal NormalText"> ++ (r !! </span><span class="DecVal Decimal">0</span><span class="Normal NormalText">) ++ </span><br /><span class="Normal NormalText">                                </span><span class="String">&quot;\n\tType: &quot;</span><span class="Normal NormalText"> ++ (r !! </span><span class="DecVal Decimal">1</span><span class="Normal NormalText">) ++ </span><br /><span class="Normal NormalText">                                </span><span class="String">&quot;\n\tAddress: &quot;</span><span class="Normal NormalText"> ++ (r !! </span><span class="DecVal Decimal">2</span><span class="Normal NormalText">) ++</span><br /><span class="Normal NormalText">                                </span><span class="String">&quot;\n\tCity: &quot;</span><span class="Normal NormalText"> ++ (r !! </span><span class="DecVal Decimal">3</span><span class="Normal NormalText">) ++</span><br /><span class="Normal NormalText">                                </span><span class="String">&quot;\n\tState: &quot;</span><span class="Normal NormalText"> ++ (r !! </span><span class="DecVal Decimal">4</span><span class="Normal NormalText">) ++</span><br /><span class="Normal NormalText">                                </span><span class="String">&quot;\n\tZip: &quot;</span><span class="Normal NormalText"> ++ (r !! </span><span class="DecVal Decimal">5</span><span class="Normal NormalText">) ++ </span><span class="String">&quot;\n&quot;</span><br /></code></pre><p>Notice the case statement in the main function. The expression evaluated by the case statement is the call to <code>parse</code>. The full type of <code>parse</code> is:</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">parse ::</span><span class="Normal NormalText"> GenParser tok () a -&gt; SourceName -&gt; [tok] -&gt; </span><span class="DataType TypeConstructor">Either</span><span class="Normal NormalText"> ParseError a</span><br /></code></pre><p>The first argument to parse is the <code>csvFile</code> parser. The <code>SourceName</code> is <code>&quot;(stdin)&quot;</code> (this is only used for error output messages), and <code>c::[Char]</code> is the sequence of characters read from stdin by <code>getContents</code>. The fact that parse returns an <code>Either</code> type necessitates the use of the case statement. <code>Either</code> is a &lsquo;disjoint union&rsquo;, and in our code this means the value can either be a ParseError or a [[String]]. We pattern match using <code>Either</code>&rsquo;s two constructors, <code>Left</code> and <code>Right</code>, to determine which action should be taken; if the parsing results in an error, we print it, otherwise we use <code>csvToText</code> to convert to human friendly text and print that.</p><p>Creating the KML output at this point is simple.</p><p>We create a KML.hs file to hold a new module, KML. This module consists of two simple strings, kmlHeader and kmlFooter, an algebraic datatype called Placemark (with fields for name, address, description, etc), a function <code>xmlify</code> which converts strings to XML friendly strings (e.g.&nbsp;replacing <code>&amp;</code> with <code>&amp;amp;</code>), and a means of converting the Placemark to a string.</p><p>To turn a Placemark into a String, we instantiate the Show class and include the KML required to create a placemark:</p><pre class="sourceCode haskell"><code><span class="Keyword">instance</span><span class="Normal NormalText"> </span><span class="Keyword Class">Show</span><span class="Normal NormalText"> Placemark </span><span class="Keyword">where</span><br /><span class="Normal NormalText">    </span><span class="Function">show</span><span class="Normal NormalText"> (Placemark name address description timestamp) = </span><br /><span class="Normal NormalText">    </span><span class="String">&quot;\t&lt;Placemark&gt;\n&quot;</span><span class="Normal NormalText"> ++ </span><br /><span class="Normal NormalText">    </span><span class="String">&quot;\t\t&lt;name&gt;&quot;</span><span class="Normal NormalText"> ++ name  ++ </span><span class="String">&quot;&lt;/name&gt;\n&quot;</span><span class="Normal NormalText"> ++</span><br /><span class="Normal NormalText">    </span><span class="String">&quot;\t\t&lt;address&gt;&quot;</span><span class="Normal NormalText"> ++ address ++ </span><span class="String">&quot;&lt;/address&gt;\n&quot;</span><span class="Normal NormalText"> ++</span><br /><span class="Normal NormalText">    </span><span class="String">&quot;\t\t&lt;description&gt;&quot;</span><span class="Normal NormalText"> ++ description ++ </span><span class="String">&quot;&lt;/description&gt;\n&quot;</span><span class="Normal NormalText"> ++</span><br /><span class="Normal NormalText">    </span><span class="String">&quot;\t\t&lt;TimeStamp&gt;&lt;when&gt;&quot;</span><span class="Normal NormalText"> ++ timestamp ++ </span><span class="String">&quot;&lt;/when&gt;&lt;/TimeStamp&gt;\n&quot;</span><span class="Normal NormalText"> ++</span><br /><span class="Normal NormalText">    </span><span class="String">&quot;\t&lt;/Placemark&gt;\n&quot;</span><br /></code></pre><p>Now to print the KML file, we rewrite the code to use the <code>show</code> function and a new conversion function, <code>placemarkFromRecord:: Record -&gt; Placemark</code>:</p><pre class="sourceCode haskell"><code><span class="Normal NormalText">main =</span><br /><span class="Normal NormalText">    </span><span class="Keyword">do</span><span class="Normal NormalText"> c &lt;- </span><span class="Function">getContents</span><br /><span class="Normal NormalText">       </span><span class="Keyword">case</span><span class="Normal NormalText"> parse csvFile </span><span class="String">&quot;(stdin)&quot;</span><span class="Normal NormalText"> c </span><span class="Keyword">of</span><br /><span class="Normal NormalText">            </span><span class="Keyword DataConstructor">Left</span><span class="Normal NormalText"> e -&gt; </span><span class="Keyword">do</span><span class="Normal NormalText"> </span><span class="Function">putStrLn</span><span class="Normal NormalText"> </span><span class="String">&quot;Error parsing input:&quot;</span><br /><span class="Normal NormalText">                         </span><span class="Function">print</span><span class="Normal NormalText"> e</span><br /><span class="Normal NormalText">            </span><span class="Keyword DataConstructor">Right</span><span class="Normal NormalText"> r -&gt; </span><span class="Keyword">do</span><span class="Normal NormalText"> </span><br /><span class="Normal NormalText">                         </span><span class="Function">putStrLn</span><span class="Normal NormalText"> kmlHeader</span><br /><span class="Normal NormalText">                         </span><span class="Function">putStrLn</span><span class="Normal NormalText"> (</span><span class="Function">concatMap</span><span class="Normal NormalText"> (</span><span class="Function">show</span><span class="Normal NormalText"> . placemarkFromRecord) r)</span><br /><span class="Normal NormalText">                         </span><span class="Function">putStrLn</span><span class="Normal NormalText"> kmlFooter</span><br /></code></pre><p>Note the use of a couple more interesting features. First we use function composition with <code>show . placemarkFromRecord</code> to create a function which first converts a record to a placemark and then converts the placemark to a string. This composition is passed as the function to concatMap, which maps it to all the elements of r (records) and then, since the result of that operation is a list of strings, concatonates those strings together.</p><p>Now we can convert a simple list of crashes to KML. We validate the KML file with the application <code>xmllint</code> and check it out in Google Earth. With that working, we move on to the real crash file.</p><h2 id="parsing-odot-data">Parsing ODOT Data</h2><p>Ultimately, what we want to do is convert a CSV file with a list of crashes into a KML file full of placemarks. We&rsquo;ve already got a Placemark type, so now we need to define a Crash type (and later we&rsquo;ll create a way to convert from a Crash to a Placemark). We create an ODOTCrash module which defines Crash related data types. Since there are a lot of fields, we let the Crash type be a logical grouping of those fields:</p><pre class="sourceCode haskell"><code><span class="Keyword">type</span><span class="Normal NormalText"> CrashID = </span><span class="DataType TypeConstructor">String</span><br /><span class="Keyword">data</span><span class="Normal NormalText"> Crash = Crash </span><br /><span class="Normal NormalText">                  {</span><br /><span class="Normal NormalText">                    </span><span class="Function FunctionDefinition">cid::</span><span class="Normal NormalText">CrashID,</span><br /><span class="Normal NormalText">                    </span><span class="Function FunctionDefinition">when::</span><span class="Normal NormalText">DateTime, </span><br /><span class="Normal NormalText">                    </span><span class="Function FunctionDefinition">location ::</span><span class="Normal NormalText"> Location, </span><br /><span class="Normal NormalText">                    </span><span class="Function FunctionDefinition">details ::</span><span class="Normal NormalText"> Details  </span><span class="Comment">--crash type, severity, etc.</span><br /><span class="Normal NormalText">                  } </span><br /></code></pre><p>We won&rsquo;t go into everything here, but another interesting data type to look at is <code>Day</code>, which is used as a fiedl in DateTime.</p><pre class="sourceCode haskell"><code><span class="Keyword">data</span><span class="Normal NormalText"> Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat </span><span class="Keyword">deriving</span><span class="Normal NormalText"> (</span><span class="Keyword Class">Show</span><span class="Normal NormalText">, </span><span class="Keyword Class">Enum</span><span class="Normal NormalText">, </span><span class="Keyword Class">Eq</span><span class="Normal NormalText">)</span><br /></code></pre><p>Note how it derives a number of standard classes (Show, Enum, and Eq). Deriving Show means there will be a default show function (which will result in strings like &ldquo;Sun&rdquo;, &ldquo;Mon&rdquo;, etc). Deriving the Enum class is helpful too; the ODOT crash format stores Days as numbers 1 through 7, and we can easily convert to these Days using the toEnum function. We wrap that in another function which deals with the difference between 0-based Haskell enums and 1-based ODOT days:</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">toDay ::</span><span class="Normal NormalText"> </span><span class="DataType TypeConstructor">Int</span><span class="Normal NormalText"> -&gt; Day</span><br /><span class="Normal NormalText">toDay n = </span><span class="Function">toEnum</span><span class="Normal NormalText"> (n</span><span class="DecVal Decimal">-1</span><span class="Normal NormalText">)::Day</span><br /></code></pre><p>To convert from CSV to a list of crashes, we need a function which takes a Record and returns a Crash. The function <code>crashFromRecord</code> does just that. It creates a Crash by supplying the crash id (field 0 of each record), along with the DateTime, Location, and Details of the crash. These other data types are constructed by similar functions which are passed just the elements of the list necessary (dateFromArray, etc). Note that crashFromRecord also takes a [Street]. This is because the crashes in the CSV file have street id #s, and we want the Crash&rsquo;s Location to contain the actual street names (so [Street] is a lookup table).</p><p>crashFromRecord and dateFromArray are shown below:</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">crashFromRecord ::</span><span class="Normal NormalText"> [Street] -&gt; Record -&gt; Crash</span><br /><span class="Normal NormalText">crashFromRecord streets r = Crash (r!!</span><span class="DecVal Decimal">0</span><span class="Normal NormalText">) </span><br /><span class="Normal NormalText">                          (dateFromArray (arrRange r (</span><span class="DecVal Decimal">1</span><span class="Normal NormalText">,</span><span class="DecVal Decimal">5</span><span class="Normal NormalText">))) </span><br /><span class="Normal NormalText">                          (locationFromArray streets (arrRange r (</span><span class="DecVal Decimal">6</span><span class="Normal NormalText">,</span><span class="DecVal Decimal">10</span><span class="Normal NormalText">)))</span><br /><span class="Normal NormalText">                          (detailsFromArray (arrRange r (</span><span class="DecVal Decimal">11</span><span class="Normal NormalText">,</span><span class="DecVal Decimal">13</span><span class="Normal NormalText">)))</span><br /><br /><span class="Function FunctionDefinition">dateFromArray ::</span><span class="Normal NormalText"> [</span><span class="DataType TypeConstructor">String</span><span class="Normal NormalText">] -&gt; DateTime</span><br /><span class="Normal NormalText">dateFromArray a = DateTime (a!!</span><span class="DecVal Decimal">0</span><span class="Normal NormalText">) (a!!</span><span class="DecVal Decimal">1</span><span class="Normal NormalText">) (a!!</span><span class="DecVal Decimal">2</span><span class="Normal NormalText">) </span><br /><span class="Normal NormalText">                           (toDay (</span><span class="Function">read</span><span class="Normal NormalText"> (a!!</span><span class="DecVal Decimal">3</span><span class="Normal NormalText">)::</span><span class="DataType TypeConstructor">Int</span><span class="Normal NormalText">)) (Hour (</span><span class="Function">read</span><span class="Normal NormalText"> (a!!</span><span class="DecVal Decimal">4</span><span class="Normal NormalText">)::</span><span class="DataType TypeConstructor">Int</span><span class="Normal NormalText">))</span><br /></code></pre><p>The function <code>arrRange</code> is just a simple function which returns the range of elements between the given start and end index (inclusively):</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">arrRange ::</span><span class="Normal NormalText"> [a] -&gt; (</span><span class="DataType TypeConstructor">Int</span><span class="Normal NormalText">, </span><span class="DataType TypeConstructor">Int</span><span class="Normal NormalText">) -&gt; [a]</span><br /><span class="Normal NormalText">arrRange </span><span class="Keyword">as</span><span class="Normal NormalText"> (r1, r2) = </span><span class="Function">take</span><span class="Normal NormalText"> (r2-r1</span><span class="DecVal Decimal">+1</span><span class="Normal NormalText">) (</span><span class="Function">drop</span><span class="Normal NormalText"> r1 </span><span class="Keyword">as</span><span class="Normal NormalText">)</span><br /></code></pre><p>We&rsquo;ll talk more about the [Street] passed to <code>crashFromRecord</code> next.</p><h2 id="crossreferencing-streets">Crossreferencing streets</h2><p>In contrast to crashFromRecord, the function that returns a Street is much simpler:</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">streetFromRecord ::</span><span class="Normal NormalText"> Record -&gt; Street</span><br /><span class="Normal NormalText">streetFromRecord r = Street (r!!</span><span class="DecVal Decimal">0</span><span class="Normal NormalText">) (r!!</span><span class="DecVal Decimal">1</span><span class="Normal NormalText">) (r!!</span><span class="DecVal Decimal">2</span><span class="Normal NormalText">) (r!!</span><span class="DecVal Decimal">3</span><span class="Normal NormalText">) (r!!</span><span class="DecVal Decimal">4</span><span class="Normal NormalText">)</span><br /></code></pre><p>Here&rsquo;s the definition of Street. It is just a bunch of strings, in the same order as they appear in the CSV file.</p><pre class="sourceCode haskell"><code><span class="Keyword">data</span><span class="Normal NormalText"> Street = Street { </span><span class="Function FunctionDefinition">county ::</span><span class="Normal NormalText"> </span><span class="DataType TypeConstructor">String</span><span class="Normal NormalText">,</span><br /><span class="Normal NormalText">                       </span><span class="Function FunctionDefinition">streetid ::</span><span class="Normal NormalText"> StreetID, </span><span class="Comment">--StreetID = String</span><br /><span class="Normal NormalText">                       </span><span class="Function FunctionDefinition">streetname ::</span><span class="Normal NormalText"> </span><span class="DataType TypeConstructor">String</span><span class="Normal NormalText">,</span><br /><span class="Normal NormalText">                       </span><span class="Function FunctionDefinition">cityid ::</span><span class="Normal NormalText"> CityID, </span><span class="Comment">--CityID = String</span><br /><span class="Normal NormalText">                       </span><span class="Function FunctionDefinition">cityname ::</span><span class="Normal NormalText"> </span><span class="DataType TypeConstructor">String</span><br /><span class="Normal NormalText">                     } </span><span class="Keyword">deriving</span><span class="Normal NormalText"> </span><span class="Keyword Class">Show</span><span class="Normal NormalText"> </span><br /></code></pre><p>The interesting thing is that the Location within a Crash stores a city name and a a couple street names (the street where the crash happened, and the nearest intersecting street), but the Crash CSV file only includes street and city ids. So to parse a crash, we first read in the streets file and create the <code>streets::[Street]</code>. Then <code>streets</code> is passed to crashFromRecord, which passes it to locationFromArray, which applies the functions <code>findCityName</code> and <code>findStreetName</code>.</p><p>To find the street name, we use a list comprehension (in a helper function) that finds all streets with the specified city and street id:</p><pre class="sourceCode haskell"><code><span class="Comment">-- find a street given a city and street id</span><br /><span class="Comment">-- find all streets matching..</span><br /><span class="Function FunctionDefinition">findStreetArr ::</span><span class="Normal NormalText"> [Street] -&gt; CityID -&gt; StreetID -&gt; [Street]</span><br /><span class="Normal NormalText">findStreetArr streets cid sid = [ s | s &lt;- streets, </span><br /><span class="Normal NormalText">                                      cityid s == cid, </span><br /><span class="Normal NormalText">                                      streetid s == (padStreet sid) ]</span><br /></code></pre><p>The list of streets returned should always only have one element. We use pattern matching to ensure this:</p><pre class="sourceCode haskell"><code><span class="Comment">-- return name of street specified by CityID, StreetID </span><br /><span class="Function FunctionDefinition">findStreetName ::</span><span class="Normal NormalText"> [Street] -&gt; CityID -&gt; StreetID -&gt; </span><span class="DataType TypeConstructor">String</span><br /><span class="Normal NormalText">findStreetName streets cid sid = </span><br /><span class="Normal NormalText">    </span><span class="Keyword">case</span><span class="Normal NormalText"> findStreetArr streets cid sid </span><span class="Keyword">of</span><br /><span class="Normal NormalText">         [] -&gt; </span><span class="Function">error</span><span class="Normal NormalText"> (</span><span class="String">&quot;no street found for city: &quot;</span><span class="Normal NormalText"> ++ cid ++ </span><span class="String">&quot;, street: &quot;</span><span class="Normal NormalText"> ++ sid)</span><br /><span class="Normal NormalText">         (x:y:zs) -&gt; </span><span class="Function">error</span><span class="Normal NormalText"> </span><span class="String">&quot;multiple streets found in street database for city: &quot;</span><span class="Normal NormalText"> ++</span><br /><span class="Normal NormalText">               cid ++ </span><span class="String">&quot;, street: &quot;</span><span class="Normal NormalText"> ++ sid</span><br /><span class="Normal NormalText">         (s:ss) -&gt; streetname s </span><br /></code></pre><p>For completeness, here is <code>locationFromArray</code><a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>:</p><pre class="sourceCode haskell"><code><span class="Comment">--parse the crash location</span><br /><span class="Comment">--streets is the street database that we'll use to find the                  </span><br /><span class="Comment">--name of cities and streets.</span><br /><span class="Function FunctionDefinition">locationFromArray ::</span><span class="Normal NormalText"> [Street] -&gt; [</span><span class="DataType TypeConstructor">String</span><span class="Normal NormalText">] -&gt; Location</span><br /><span class="Normal NormalText">locationFromArray streets a = Location (findCityName streets (a!!</span><span class="DecVal Decimal">0</span><span class="Normal NormalText">)) </span><br /><span class="Normal NormalText">                               (findStreetName streets (a!!</span><span class="DecVal Decimal">0</span><span class="Normal NormalText">) (a!!</span><span class="DecVal Decimal">1</span><span class="Normal NormalText">))</span><br /><span class="Normal NormalText">                               (findStreetName streets (a!!</span><span class="DecVal Decimal">0</span><span class="Normal NormalText">) (a!!</span><span class="DecVal Decimal">2</span><span class="Normal NormalText">))</span><br /><span class="Normal NormalText">                               (parseDistance (a!!</span><span class="DecVal Decimal">3</span><span class="Normal NormalText">))</span><br /><span class="Normal NormalText">                               (toDirection (</span><span class="Function">read</span><span class="Normal NormalText"> (a!!</span><span class="DecVal Decimal">4</span><span class="Normal NormalText">)::</span><span class="DataType TypeConstructor">Int</span><span class="Normal NormalText">))</span><br /></code></pre><h2 id="sorting-and-filtering">Sorting and Filtering</h2><p>Google Earth has a feature that allows you to take a &lsquo;tour&rsquo; of placemarks in a folder, jumping around from one to another. If we sort the list of crashes chronologically, it would make such a tour much more useful.</p><p>The List module&rsquo;s <code>sort</code> function is a great help for sorting things. However, those things have to be sortable. Meaning, they have to be a member of the <code>Ord</code> class, a class for ordered datatypes. We instantiate that class by providing a minimally complete definition: we implement just the function <code>&lt;=</code>.</p><p>We say that crash1 is &ldquo;less than&rdquo; crash2 if crash1 happened before crash2 (using the DateTime&rsquo;s <code>&lt;=</code> operator):</p><pre class="sourceCode haskell"><code><span class="Keyword">instance</span><span class="Normal NormalText"> </span><span class="Keyword Class">Ord</span><span class="Normal NormalText"> Crash </span><span class="Keyword">where</span><br /><span class="Normal NormalText">   (&lt;=) c1 c2 = (when c1) &lt;= (when c2)</span><br /></code></pre><p>We also implement this function for DateTime, and we do that by again passing the comparison off to another function (which you can find in the source).</p><pre class="sourceCode haskell"><code><span class="Keyword">instance</span><span class="Normal NormalText"> </span><span class="Keyword Class">Ord</span><span class="Normal NormalText"> DateTime </span><span class="Keyword">where</span><br /><span class="Normal NormalText">    (&lt;=) d1 d2 = </span><br /><span class="Normal NormalText">        cmp (dateToTuple d1) (dateToTuple d2)     </span><br /></code></pre><p>Having implemented these, now we can sort:</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">crashes ::</span><span class="Normal NormalText"> [Crash]</span><br /><span class="Normal NormalText">sortedcrashes = sort crashes</span><br /></code></pre><p>Another interesting thing that we can implement is filtering. We&rsquo;ll make use of the <code>filter</code> function because we only want crashes that are either a distance 0 from intersections are in the center of them. These are the only crashes we know how to map at this point.</p><p>To filter the list of crashes, we create the following function which compares the distance field of the crash location with 0, or compares the direction with Center.</p><pre class="sourceCode haskell"><code><span class="Function FunctionDefinition">isIntersectionCrash ::</span><span class="Normal NormalText"> Crash -&gt; </span><span class="DataType TypeConstructor">Bool</span><br /><span class="Normal NormalText">isIntersectionCrash crash = distance (location crash) == Distance </span><span class="DecVal Decimal">0</span><span class="Normal NormalText"> ||</span><br /><span class="Normal NormalText">                            direction (location crash) == Center </span><br /></code></pre><h1 id="results-&amp;-conclusion">Results &amp; Conclusion</h1><p>Although the crash mapper doesn&rsquo;t do everything that it was originally intended to do, I&rsquo;m quite happy with the result. In its current form, it will take a list of crashes in ODOT&rsquo;s CSV format and create a KML file which can be opened in Google Earth. Each crash (Placemark) includes a timestamp, and the set of placemarks in the KML file is sorted by date. This allows the user to use tools included in Google Earth to view just the crashes within a specified time frame and to take a &ldquo;tour&rdquo;, in chronological order, of all the crashes over the last ten years.</p><p>By creating this map, users should be able to look at an area they are interested in and examine it for trends. For instance, by zooming in on downtown Beaverton you can see that there have been a high number of crashes along Farmington road and 1st Ave, which is scary considering that is where Beaverton High School is located.</p><p>Here is a screenshot of Google Earth, showing all bike crashes in Washington County over the last ~ 10 years: <img src="./screenshot-sm.jpg" title="screenshot" alt="screenshot of Google Earth showing crashes" /></p><p>As cool as it is, there is a long list of improvements that could be made to the program:</p><ul><li>each placemark could include a link to information (articles, etc) on the web related to that crash</li><li>investigate the use of <a href="http://www.keithsheppard.name/txt-sushi/">TxtSushi</a> for handling the CSV files. TxtSushi provides a way of querying CSV files as if they were SQL databases.</li><li>fix street names. There are a number of streets that Google Earth can&rsquo;t find. This is either because their name is something like &ldquo;Unknown Street #11000&rdquo; (because ODOT lost some data in the 90&rsquo;s) or because the street is a highway, and highway is abbreviated &lsquo;HY&rsquo; by ODOT, but Google Earth expects &lsquo;HWY&rsquo;.</li><li>create separate folders and icon styles for bike and pedestrian crashes, and separate styles for fatal vs.&nbsp;non-fatal crashes.</li><li>Use the <a href="http://www.haskell.org/haskellwiki/HXT">Haskell XML toolkit</a> to read the KMZ file to grab GPS intersection locations and use those to create placemarks for non-intersection crashes (Google Earth looks up the intersections of placemarks in the KML file, and when the folder of placemarks is saved as a KMZ file it includes the GPS locations).</li><li>figure out a way to map crashes which are recorded by ODOT as milepoints along highways.</li></ul><h2 id="appendix-code">Appendix: Code</h2><p>All of the source code is <a href="http://github.com/techieshark/crashmapper">available here</a>.</p><div class="footnotes"><hr /><ol><li id="fn1"><p>source: http://www-nrd.nhtsa.dot.gov/Pubs/810936.PDF <a href="#fnref1" class="footnoteBackLink" title="Jump back to footnote 1">&#8617;</a></p></li><li id="fn2"><p>source: http://www.fhwa.dot.gov/environment/bikeped/study.htm#s3 <a href="#fnref2" class="footnoteBackLink" title="Jump back to footnote 2">&#8617;</a></p></li><li id="fn3"><p>source: http://www.bikeleague.org/media/facts/#crash_cost <a href="#fnref3" class="footnoteBackLink" title="Jump back to footnote 3">&#8617;</a></p></li><li id="fn4"><p>source: http://code.google.com/apis/kml/documentation/kmlreference.html <a href="#fnref4" class="footnoteBackLink" title="Jump back to footnote 4">&#8617;</a></p></li><li id="fn5"><p>Full code is in file ch16/csv9.hs from <a href="http://book.realworldhaskell.org/read/using-parsec.html">Chapter 16, Using Parsec</a>. <a href="#fnref5" class="footnoteBackLink" title="Jump back to footnote 5">&#8617;</a></p></li><li id="fn6"><p>we&rsquo;re really talking about lists, so this should actually be called locationFromList. <a href="#fnref6" class="footnoteBackLink" title="Jump back to footnote 6">&#8617;</a></p></li></ol></div></body></html>
